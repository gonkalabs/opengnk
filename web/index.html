<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Proxy Playground</title>
<style>
:root {
  --bg: #0d1117;
  --surface: #161b22;
  --border: #30363d;
  --text: #c9d1d9;
  --muted: #8b949e;
  --accent: #58a6ff;
  --accent-dim: #1f6feb;
  --user-bg: #1f6feb;
  --assistant-bg: #21262d;
  --danger: #f85149;
  --warn: #e3b341;
  --warn-dim: rgba(227,179,65,.15);
  --green: #3fb950;
  --green-dim: rgba(63,185,80,.10);
  --radius: 8px;
  --font: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
}
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font);font-size:14px}
.app{display:grid;grid-template-rows:auto 1fr auto;height:100vh;max-width:800px;margin:0 auto}

/* top bar */
.topbar{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid var(--border)}
.topbar .dot{width:8px;height:8px;border-radius:50%;background:var(--accent);flex-shrink:0}
.topbar select{background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:var(--radius);padding:4px 8px;font-family:var(--font);font-size:13px;cursor:pointer;outline:none}
.topbar select:focus{border-color:var(--accent)}
.topbar .spacer{flex:1}
.topbar label{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px;cursor:pointer;user-select:none}
.topbar input[type=checkbox]{accent-color:var(--accent)}

/* log */
.log{overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:16px}
.log::-webkit-scrollbar{width:6px}
.log::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
.log .welcome{color:var(--muted);text-align:center;padding:40px 0;line-height:1.6;font-size:13px}
.log .welcome kbd{background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:1px 5px;font-size:12px}

/* entry */
.entry{display:flex;flex-direction:column;gap:6px;max-width:100%}
.entry.you{align-items:flex-end}
.entry.bot{align-items:flex-start}

.msg-row{display:flex;gap:10px;max-width:100%}
.entry.you .msg-row{flex-direction:row-reverse}

.tag{flex-shrink:0;width:28px;height:28px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;text-transform:uppercase;align-self:flex-start;margin-top:2px}
.entry.you .tag{background:var(--user-bg);color:#fff}
.entry.bot .tag{background:var(--assistant-bg);color:var(--accent);border:1px solid var(--border)}

.bubble{padding:8px 12px;border-radius:var(--radius);line-height:1.55;white-space:pre-wrap;word-break:break-word;max-width:85%}
.entry.you .bubble{background:var(--user-bg);color:#fff;border-bottom-right-radius:2px}
.entry.bot .bubble{background:var(--assistant-bg);border:1px solid var(--border);border-bottom-left-radius:2px}

/* cursor blink */
.cursor::after{content:'_';animation:blink .7s step-end infinite}
@keyframes blink{50%{opacity:0}}

/* ── sanitize diff panel ── */
.san-wrap{max-width:calc(85% + 38px);width:100%}
.entry.you .san-wrap{align-self:flex-end}
.entry.bot .san-wrap{align-self:flex-start}

/* toggle pill */
.san-pill{
  display:inline-flex;align-items:center;gap:6px;
  padding:3px 10px;border-radius:20px;font-size:11px;font-weight:600;
  cursor:pointer;user-select:none;border:1px solid;transition:opacity .15s;
}
.san-pill:hover{opacity:.8}
.san-pill.redact{background:rgba(227,179,65,.12);border-color:rgba(227,179,65,.35);color:var(--warn)}
.san-pill.restore{background:var(--green-dim);border-color:rgba(63,185,80,.30);color:var(--green)}
.san-pill svg{flex-shrink:0}

/* expandable panel */
.san-detail{
  margin-top:5px;overflow:hidden;
  max-height:0;transition:max-height .3s ease,opacity .2s ease;opacity:0;
}
.san-detail.open{max-height:600px;opacity:1}

/* diff view: two bubbles side by side */
.diff-view{
  display:grid;grid-template-columns:1fr 1fr;gap:8px;
}
@media(max-width:560px){.diff-view{grid-template-columns:1fr}}

.diff-col{
  background:var(--surface);border:1px solid var(--border);
  border-radius:var(--radius);overflow:hidden;
}
.diff-col-head{
  padding:4px 10px;font-size:10px;font-weight:700;text-transform:uppercase;
  letter-spacing:.05em;border-bottom:1px solid var(--border);
}
.diff-col.original .diff-col-head{color:var(--warn);background:rgba(227,179,65,.06)}
.diff-col.redacted  .diff-col-head{color:var(--muted);background:rgba(255,255,255,.02)}
.diff-col-body{
  padding:8px 10px;font-size:12px;line-height:1.6;
  white-space:pre-wrap;word-break:break-word;
}

/* inline highlight for sensitive spans */
.hi-orig{
  background:rgba(227,179,65,.25);color:#f0c060;
  border-radius:3px;padding:0 2px;
}
.hi-tok{
  background:rgba(139,148,158,.15);color:var(--muted);
  border-radius:3px;padding:0 2px;font-size:11px;
}

/* restore table (response side) */
.restore-table{width:100%;border-collapse:collapse;font-size:12px;
  background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden}
.restore-table thead tr{background:rgba(255,255,255,.03)}
.restore-table th{padding:5px 10px;text-align:left;color:var(--muted);font-weight:600;border-bottom:1px solid var(--border)}
.restore-table td{padding:5px 10px;border-bottom:1px solid rgba(48,54,61,.5);vertical-align:top}
.restore-table tr:last-child td{border-bottom:none}
.restore-table .tok{color:var(--muted);font-size:11px}
.restore-table .arrow{color:var(--muted);padding:5px 4px}
.restore-table .orig{color:var(--green)}

/* error */
.err-line{background:rgba(248,81,73,.1);border-left:3px solid var(--danger);padding:6px 10px;border-radius:0 var(--radius) var(--radius) 0;color:var(--danger);font-size:13px}

/* input bar */
.inputbar{display:flex;gap:8px;padding:12px 16px;border-top:1px solid var(--border)}
.inputbar textarea{flex:1;resize:none;background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:var(--radius);padding:8px 12px;font-family:var(--font);font-size:14px;line-height:1.4;outline:none;min-height:38px;max-height:160px}
.inputbar textarea:focus{border-color:var(--accent)}
.inputbar textarea::placeholder{color:var(--muted)}
.inputbar button{background:var(--accent-dim);color:#fff;border:none;border-radius:var(--radius);padding:0 16px;font-family:var(--font);font-size:13px;font-weight:600;cursor:pointer;white-space:nowrap;transition:background .15s}
.inputbar button:hover:not(:disabled){background:var(--accent)}
.inputbar button:disabled{opacity:.35;cursor:not-allowed}
</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <span class="dot"></span>
    <select id="mdl"><option value="">loading...</option></select>
    <span class="spacer"></span>
    <label><input type="checkbox" id="stm" checked> stream</label>
  </div>
  <div class="log" id="log">
    <div class="welcome" id="welcome">
      no messages yet<br>type below and press <kbd>Enter</kbd> to start
    </div>
  </div>
  <div class="inputbar">
    <textarea id="inp" rows="1" placeholder="say something..."></textarea>
    <button id="go">send</button>
  </div>
</div>

<script>
const log     = document.getElementById('log');
const inp     = document.getElementById('inp');
const go_     = document.getElementById('go');
const mdl     = document.getElementById('mdl');
const stm     = document.getElementById('stm');
let   welcome = document.getElementById('welcome');
let   hist    = [];

const ICON_SHIELD  = `<svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M8 1L2 3.5v4C2 11 5 14 8 15c3-1 6-4 6-7.5v-4L8 1z"/></svg>`;
const ICON_RESTORE = `<svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>`;

// ── helpers ────────────────────────────────────────────────────────────────
inp.addEventListener('input', () => {
  inp.style.height = 'auto';
  inp.style.height = Math.min(inp.scrollHeight, 160) + 'px';
});

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ── models ─────────────────────────────────────────────────────────────────
(async () => {
  try {
    const r = await fetch('/v1/models');
    const d = await r.json();
    mdl.innerHTML = '';
    (d.data||[]).forEach(m => {
      const o = document.createElement('option');
      o.value = m.id; o.textContent = m.id; mdl.appendChild(o);
    });
    if (!mdl.options.length) mdl.innerHTML = '<option value="">no models</option>';
  } catch(e) { mdl.innerHTML = '<option value="">offline</option>'; }
})();

// ── parse header ───────────────────────────────────────────────────────────
// atob() only handles Latin-1; the JSON contains UTF-8 (e.g. «TOKEN» guillemets
// and Cyrillic originals). Decode via Uint8Array → TextDecoder instead.
function b64ToUtf8(b64) {
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new TextDecoder().decode(bytes);
}

function parseRedactions(headers) {
  try {
    const raw = headers.get('x-sanitize-redactions');
    if (!raw) return null;
    return JSON.parse(b64ToUtf8(raw));
  } catch(_) { return null; }
}

// ── build redacted version of text ────────────────────────────────────────
// Returns the text with originals replaced by their tokens.
function applyRedactions(text, redactions) {
  if (!redactions || !redactions.length) return text;
  let result = text;
  // Sort by length descending to avoid partial replacements.
  const sorted = [...redactions].sort((a,b) => b.original.length - a.original.length);
  for (const r of sorted) {
    // Skip if the original is itself a token placeholder — prevents double-redaction
    // when the text already contains «TOKEN_...» from a previous pass.
    if (r.original.startsWith('«TOKEN_')) continue;
    // Skip if the token is already present verbatim (already redacted).
    if (result.includes(r.token)) continue;
    result = result.split(r.original).join(r.token);
  }
  return result;
}

// ── build highlighted HTML for a text given redaction list ─────────────────
function highlightOriginal(text, redactions) {
  if (!redactions || !redactions.length) return esc(text);
  // Sort by position of first occurrence.
  const sorted = [...redactions].sort((a,b) => {
    const ia = text.indexOf(a.original), ib = text.indexOf(b.original);
    return ia - ib;
  });
  let result = esc(text);
  // Replace each original with a highlighted span (work on escaped string,
  // so escape the search term too).
  for (const r of sorted) {
    const escapedOrig = esc(r.original);
    const escapedTok  = esc(r.token);
    result = result.split(escapedOrig).join(
      `<span class="hi-orig" title="${escapedTok}">${escapedOrig}</span>`
    );
  }
  return result;
}

function highlightRedacted(text, redactions) {
  if (!redactions || !redactions.length) return esc(text);
  let result = esc(text);
  for (const r of redactions) {
    const escapedTok = esc(r.token);
    result = result.split(escapedTok).join(
      `<span class="hi-tok">${escapedTok}</span>`
    );
  }
  return result;
}

// ── diff panel for user messages ───────────────────────────────────────────
function buildRedactDiff(originalText, redactions) {
  if (!redactions || !redactions.length) return null;

  const redactedText = applyRedactions(originalText, redactions);
  // If nothing actually changed, don't show the panel.
  if (redactedText === originalText) return null;

  const wrap = document.createElement('div');
  wrap.className = 'san-wrap';

  const pill = document.createElement('div');
  pill.className = 'san-pill redact';
  pill.innerHTML = `${ICON_SHIELD} ${redactions.length} value${redactions.length>1?'s':''} redacted — click to see what was sent`;

  const detail = document.createElement('div');
  detail.className = 'san-detail';

  const diffView = document.createElement('div');
  diffView.className = 'diff-view';

  // Original column
  const colOrig = document.createElement('div');
  colOrig.className = 'diff-col original';
  colOrig.innerHTML = `
    <div class="diff-col-head">your message</div>
    <div class="diff-col-body">${highlightOriginal(originalText, redactions)}</div>`;

  // Redacted column
  const colRed = document.createElement('div');
  colRed.className = 'diff-col redacted';
  colRed.innerHTML = `
    <div class="diff-col-head">sent to LLM</div>
    <div class="diff-col-body">${highlightRedacted(redactedText, redactions)}</div>`;

  diffView.appendChild(colOrig);
  diffView.appendChild(colRed);
  detail.appendChild(diffView);

  const toggleDiff = () => {
    detail.classList.toggle('open');
    const open = detail.classList.contains('open');
    pill.innerHTML = `${ICON_SHIELD} ${redactions.length} value${redactions.length>1?'s':''} redacted ${open?'▲':'▼'}`;
  };
  pill.addEventListener('click', toggleDiff);

  // Auto-open so the diff is visible immediately.
  wrap.appendChild(pill);
  wrap.appendChild(detail);
  // Defer so the element is in the DOM before we trigger the transition.
  requestAnimationFrame(() => toggleDiff());
  return wrap;
}

// ── restore panel for assistant messages ──────────────────────────────────
function buildRestorePanel(redactions) {
  if (!redactions || !redactions.length) return null;

  const wrap = document.createElement('div');
  wrap.className = 'san-wrap';

  const pill = document.createElement('div');
  pill.className = 'san-pill restore';
  pill.innerHTML = `${ICON_RESTORE} ${redactions.length} value${redactions.length>1?'s':''} restored in response — click to inspect`;

  const detail = document.createElement('div');
  detail.className = 'san-detail';

  const table = document.createElement('table');
  table.className = 'restore-table';
  table.innerHTML = `<thead><tr><th>placeholder in LLM response</th><th></th><th>restored to original</th></tr></thead>`;
  const tbody = document.createElement('tbody');
  redactions.forEach(r => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="tok">${esc(r.token)}</td><td class="arrow">→</td><td class="orig">${esc(r.original)}</td>`;
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  detail.appendChild(table);

  pill.addEventListener('click', () => {
    detail.classList.toggle('open');
    const open = detail.classList.contains('open');
    pill.innerHTML = `${ICON_RESTORE} ${redactions.length} value${redactions.length>1?'s':''} restored ${open?'▲':'▼'}`;
  });

  wrap.appendChild(pill);
  wrap.appendChild(detail);
  return wrap;
}

// ── add entry ──────────────────────────────────────────────────────────────
function addEntry(role, text) {
  if (welcome) { welcome.remove(); welcome = null; }

  const entry = document.createElement('div');
  entry.className = 'entry ' + (role === 'user' ? 'you' : 'bot');

  const row = document.createElement('div');
  row.className = 'msg-row';

  const tag = document.createElement('div');
  tag.className = 'tag';
  tag.textContent = role === 'user' ? 'Y' : 'A';

  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  bubble.textContent = text;

  row.appendChild(tag);
  row.appendChild(bubble);
  entry.appendChild(row);
  log.appendChild(entry);
  log.scrollTop = log.scrollHeight;
  return { bubble, entry };
}

function addErr(msg) {
  if (welcome) { welcome.remove(); welcome = null; }
  const d = document.createElement('div');
  d.className = 'err-line';
  d.textContent = msg;
  log.appendChild(d);
  log.scrollTop = log.scrollHeight;
}

// ── send ───────────────────────────────────────────────────────────────────
async function send() {
  const txt = inp.value.trim();
  if (!txt) return;

  const { entry: userEntry } = addEntry('user', txt);
  // Store original text for now; we'll replace it with the redacted version
  // once we get the response headers back (so history never leaks real values).
  hist.push({ role: 'user', content: txt });
  const userHistIdx = hist.length - 1;

  inp.value = ''; inp.style.height = 'auto'; go_.disabled = true;

  const body = { model: mdl.value, messages: [...hist], stream: stm.checked };

  try {
    if (body.stream) {
      const res = await fetch('/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) { const e = await res.json().catch(()=>({})); throw new Error(e.error||e.detail||res.status); }

      const redactions = parseRedactions(res.headers);

      // Replace the user history entry with the redacted version so future
      // turns never send the real value back to the LLM.
      if (redactions && redactions.length > 0) {
        hist[userHistIdx].content = applyRedactions(txt, redactions);
      }

      // Attach diff panel to user message.
      const diffWidget = buildRedactDiff(txt, redactions);
      if (diffWidget) userEntry.appendChild(diffWidget);

      const { bubble, entry: botEntry } = addEntry('assistant', '');
      bubble.classList.add('cursor');

      const reader = res.body.getReader();
      const dec = new TextDecoder();
      let full = '', buf = '';
      for (;;) {
        const { done, value } = await reader.read();
        if (done) break;
        buf += dec.decode(value, { stream: true });
        const lines = buf.split('\n'); buf = lines.pop() || '';
        for (const l of lines) {
          if (!l.startsWith('data: ')) continue;
          const d = l.slice(6); if (d === '[DONE]') continue;
          try { const j = JSON.parse(d); const c = j.choices?.[0]?.delta?.content; if(c){full+=c;bubble.textContent=full;} } catch(_){}
        }
        log.scrollTop = log.scrollHeight;
      }
      bubble.classList.remove('cursor');

      // Store the assistant response with tokens still in place (not the
      // restored version) so the LLM never sees the real values in history.
      if (full) {
        const fullRedacted = redactions ? applyRedactions(full, redactions) : full;
        hist.push({ role: 'assistant', content: fullRedacted });
      }

      // Attach restore panel to assistant message.
      const restoreWidget = buildRestorePanel(redactions);
      if (restoreWidget) botEntry.appendChild(restoreWidget);

    } else {
      const res = await fetch('/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) { const e = await res.json().catch(()=>({})); throw new Error(e.error||e.detail||res.status); }

      const redactions = parseRedactions(res.headers);

      // Replace the user history entry with the redacted version.
      if (redactions && redactions.length > 0) {
        hist[userHistIdx].content = applyRedactions(txt, redactions);
      }

      const diffWidget = buildRedactDiff(txt, redactions);
      if (diffWidget) userEntry.appendChild(diffWidget);

      const data = await res.json();
      const content = data.choices?.[0]?.message?.content || '(empty)';
      const { entry: botEntry } = addEntry('assistant', content);

      // Store assistant response with tokens, not restored values.
      const contentRedacted = redactions ? applyRedactions(content, redactions) : content;
      hist.push({ role: 'assistant', content: contentRedacted });

      const restoreWidget = buildRestorePanel(redactions);
      if (restoreWidget) botEntry.appendChild(restoreWidget);
    }
  } catch(e) { addErr(e.message || 'request failed'); }

  go_.disabled = false;
  inp.focus();
}

go_.addEventListener('click', send);
inp.addEventListener('keydown', e => { if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();send();} });
inp.focus();
</script>
</body>
</html>
